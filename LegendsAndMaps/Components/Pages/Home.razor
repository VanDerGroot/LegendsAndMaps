@page "/"

<PageTitle>Home</PageTitle>

<h1>Legends & Maps</h1>

<div class="row g-3">
	<div class="col-12 col-lg-4">
		<div class="card">
			<div class="card-header">
				Sets
			</div>
			<div class="card-body">
				<div class="mb-2">
					<label class="form-label">New set name</label>
					<input class="form-control" @bind-value="_newSetName" @bind-value:event="oninput" placeholder="e.g. Visited" />
				</div>

				<div class="mb-3">
					<label class="form-label">Color</label>
					<div class="d-flex align-items-center gap-2">
						<input class="form-control" @bind-value="_newSetColor" @bind-value:event="oninput" placeholder="e.g. #2f80ed or red" />
						<input class="form-control form-control-color" type="color" value="@_newSetColorPicker" @onchange="OnNewSetColorPicked" />
					</div>
				</div>

				<div class="d-flex gap-2 mb-3">
					<button class="btn btn-primary" @onclick="CreateSet" disabled="@string.IsNullOrWhiteSpace(_newSetName)">Create</button>
					<button class="btn btn-outline-secondary" @onclick="ClearSelection">Clear selection</button>
				</div>

				<div class="form-check mb-3">
					<input class="form-check-input" type="checkbox" id="showNz" @bind="_showNewZealand" />
					<label class="form-check-label" for="showNz">Show New Zealand</label>
				</div>

				@if (_sets.Count == 0)
				{
					<div class="text-muted">No sets yet. Create one to start assigning countries.</div>
				}
				else
				{
					<div class="list-group">
						@foreach (var set in _sets)
						{
							var isActive = _activeSetId == set.Id;
							var isDefault = set.Id == MapState.DefaultSetId;
							<button type="button" class="list-group-item list-group-item-action d-flex align-items-center justify-content-between @(isActive ? "active" : "")"
									@onclick="() => SelectSet(set.Id)">
								<span class="d-flex align-items-center gap-2">
									<span class="set-swatch" style="background-color:@SafeInlineColor(set.ColorHex)"></span>
									<span>@set.Name</span>
								</span>
								<span class="d-flex align-items-center gap-2">
									<span class="badge text-bg-secondary">@CountCountries(set.Id)</span>
									@if (!isDefault)
									{
										<span>
											<button class="btn btn-sm btn-outline-danger" @onclick:stopPropagation="true" @onclick="() => DeleteSet(set.Id)">Delete</button>
										</span>
									}
								</span>
							</button>
						}
					</div>
				}

				@if (SelectedSet is not null)
				{
					<hr />
					<div class="mb-2">
						<label class="form-label">Selected set color</label>
						<div class="d-flex align-items-center gap-2">
							<input class="form-control" @bind-value="_activeSetColor" @bind-value:event="oninput" placeholder="e.g. rebeccapurple" />
							<input class="form-control form-control-color" type="color" value="@_activeSetColorPicker" @onchange="OnActiveSetColorPicked" />
							<button class="btn btn-outline-primary" @onclick="ApplyActiveSetColor">Apply</button>
						</div>
					</div>
				}

				<hr />
				<div class="small text-muted">
					Click a country to assign it to the selected set. Click it again to unassign.
				</div>
			</div>
		</div>

		<div class="card mt-3">
			<div class="card-header p-0">
				<button type="button" class="btn yaml-toggle w-100 d-flex align-items-center justify-content-between px-3 py-2" @onclick="ToggleYamlImport" aria-expanded="@_yamlImportExpanded">
					<span>YAML</span>
					<span class="yaml-arrow">@(_yamlImportExpanded ? "▼" : "▶")</span>
				</button>
			</div>
			@if (_yamlImportExpanded)
			{
				<div class="card-body">
				<div class="mb-2">
					<label class="form-label">Paste YAML</label>
					<textarea class="form-control" rows="10" @bind-value="_yamlText" @bind-value:event="oninput" spellcheck="false" placeholder="@YamlPlaceholder"></textarea>
				</div>

				<div class="d-flex gap-2">
					<button class="btn btn-success" @onclick="ImportYaml" disabled="@string.IsNullOrWhiteSpace(_yamlText)">Import YAML</button>
					<button class="btn btn-outline-primary" @onclick="ExportYaml">Export YAML</button>
					<button class="btn btn-outline-secondary" @onclick="ClearYaml">Clear</button>
				</div>

				@if (!string.IsNullOrWhiteSpace(_yamlError))
				{
					<div class="alert alert-danger mt-3 mb-0" role="alert">@_yamlError</div>
				}
				else if (_yamlWarnings.Count > 0)
				{
					<div class="alert alert-warning mt-3 mb-0" role="alert">
						@foreach (var w in _yamlWarnings)
						{
							<div>@w</div>
						}
					</div>
				}
				else if (_yamlImported)
				{
					<div class="alert alert-success mt-3 mb-0" role="alert">Imported.</div>
				}

				<div class="small text-muted mt-2">
					Supported formats: list under <code>sets</code> or mapping under <code>sets</code>. Country ids should be ISO (e.g. NZ, USA).
				</div>
				</div>
			}
		</div>
	</div>

	<div class="col-12 col-lg-8">
		<div class="card">
			<div class="card-body">
				<div class="row g-2 align-items-end">
					<div class="col-12 col-md-8">
						<label class="form-label">Map name</label>
						<input class="form-control" @bind-value="_mapName" @bind-value:event="oninput" placeholder="e.g. Europe trip 2026" />
					</div>
					<div class="col-12 col-md-4">
						<div class="small text-muted">Used for PNG export + legend.</div>
					</div>
				</div>
			</div>
		</div>

		<div class="mt-3">
			<WorldMap ColorsByCountryId="@_colorsByCountry" GroupNameByCountryId="@_groupNameByCountry" HiddenCountryIds="@HiddenCountries" CountryClicked="OnCountryClicked" LegendItems="@LegendItems" MapName="@_mapName" />
		</div>
	</div>
</div>

@code {
	[Inject] private IMapStateService MapState { get; set; } = default!;
	[Inject] private IJSRuntime Js { get; set; } = default!;
	[Inject] private LegendsAndMaps.Services.CountryCatalog CountryCatalog { get; set; } = default!;

	private string _newSetName = "";
	private string _newSetColor = "#2f80ed";
	private string _newSetColorPicker = "#2f80ed";
	private Guid? _activeSetId;
	private string _activeSetColor = "#2f80ed";
	private string _activeSetColorPicker = "#2f80ed";

	private IReadOnlyList<LegendsAndMaps.State.CountrySet> _sets = Array.Empty<LegendsAndMaps.State.CountrySet>();
	private IReadOnlyDictionary<string, string> _colorsByCountry = new Dictionary<string, string>();
	private IReadOnlyDictionary<string, string> _groupNameByCountry = new Dictionary<string, string>();
	private bool _showNewZealand;

	private string _yamlText = "";
	private string _yamlError = "";
	private List<string> _yamlWarnings = new();
	private bool _yamlImported;
	private bool _yamlImportExpanded;
	private YamlMapImporter _yamlImporter = default!;

	private string _mapName = "World Map";

	private const string YamlPlaceholder = "sets:\n  - name: Visited\n    color: '#2f80ed'\n    countries: [NZ, AU]\n  - name: Wishlist\n    color: '#e91e63'\n    countries:\n      - JP";

	private IReadOnlyCollection<string> HiddenCountries => _showNewZealand
		? Array.Empty<string>()
		: new[] { "NZ" };

	private IReadOnlyList<MapLegendItem> LegendItems => _sets
		.Select(s => new MapLegendItem(s.Name, s.ColorHex))
		.ToList();

	private LegendsAndMaps.State.CountrySet? SelectedSet => _activeSetId is null
		? null
		: _sets.FirstOrDefault(s => s.Id == _activeSetId.Value);

	protected override void OnInitialized()
	{
		_yamlImporter = new YamlMapImporter(CountryCatalog);
		RefreshFromState();
		MapState.StateChanged += OnStateChanged;
	}

	private void OnStateChanged()
	{
		_ = InvokeAsync(() =>
		{
			RefreshFromState();
			StateHasChanged();
		});
	}

	private void RefreshFromState()
	{
		_sets = MapState.GetSets();
		_colorsByCountry = MapState.GetCountryColorsById();

		var setNameById = _sets.ToDictionary(s => s.Id, s => s.Name);
		var defaultName = setNameById.TryGetValue(MapState.DefaultSetId, out var dn) ? dn : "No data";
		var assignments = MapState.GetCountryAssignments();
		var groupMap = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
		foreach (var (countryId, setId) in assignments)
		{
			var name = setNameById.TryGetValue(setId, out var n) ? n : defaultName;
			groupMap[countryId] = name;
		}
		_groupNameByCountry = groupMap;

		if (SelectedSet is not null)
		{
			_activeSetColor = SelectedSet.ColorHex;
			_activeSetColorPicker = ToHexOrFallback(_activeSetColor);
		}

		if (_activeSetId is not null && _sets.All(s => s.Id != _activeSetId.Value))
		{
			_activeSetId = null;
		}
	}

	private void CreateSet()
	{
		var created = MapState.AddSet(_newSetName, _newSetColor);
		_activeSetId = created.Id;
		_newSetName = "";
		_newSetColorPicker = ToHexOrFallback(_newSetColor);
	}

	private void SelectSet(Guid id)
	{
		_activeSetId = id;
		var set = _sets.FirstOrDefault(s => s.Id == id);
		if (set is not null)
		{
			_activeSetColor = set.ColorHex;
			_activeSetColorPicker = ToHexOrFallback(_activeSetColor);
		}
	}

	private void ClearSelection() => _activeSetId = null;
	private void DeleteSet(Guid id)
	{
		if (_activeSetId == id)
		{
			_activeSetId = null;
		}
		MapState.RemoveSet(id);
	}

	private int CountCountries(Guid setId)
	{
		return MapState.GetCountryAssignments().Values.Count(v => v == setId);
	}

	private void OnNewSetColorPicked(ChangeEventArgs e)
	{
		var newColor = e.Value?.ToString();
		if (string.IsNullOrWhiteSpace(newColor))
		{
			return;
		}
		_newSetColorPicker = newColor;
		_newSetColor = newColor;
	}

	private void OnActiveSetColorPicked(ChangeEventArgs e)
	{
		var newColor = e.Value?.ToString();
		if (string.IsNullOrWhiteSpace(newColor))
		{
			return;
		}
		_activeSetColorPicker = newColor;
		_activeSetColor = newColor;
	}

	private void ApplyActiveSetColor()
	{
		if (_activeSetId is null)
		{
			return;
		}

		var set = SelectedSet;
		if (set is null)
		{
			return;
		}

		MapState.UpdateSet(set.Id, set.Name, _activeSetColor);
	}

	private static string SafeInlineColor(string? color)
	{
		if (string.IsNullOrWhiteSpace(color))
		{
			return "#808080";
		}

		var c = color.Trim();
		if (c.Length > 40)
		{
			c = c[..40];
		}

		// Prevent breaking out of the style attribute.
		c = c.Replace(";", "", StringComparison.Ordinal)
			 .Replace("\r", "", StringComparison.Ordinal)
			 .Replace("\n", "", StringComparison.Ordinal)
			 .Trim();

		return string.IsNullOrWhiteSpace(c) ? "#808080" : c;
	}

	private static string ToHexOrFallback(string color)
	{
		// If the current color isn't hex, keep the picker usable by falling back.
		// The text input still preserves the original value.
		if (string.IsNullOrWhiteSpace(color))
		{
			return "#2f80ed";
		}

		var c = color.Trim();
		if (c.StartsWith('#') && (c.Length == 4 || c.Length == 7))
		{
			return c;
		}

		return "#2f80ed";
	}

	private Task OnCountryClicked(string countryId)
	{
		if (_activeSetId is null)
		{
			return Task.CompletedTask;
		}

		if (_activeSetId == MapState.DefaultSetId)
		{
			// Default group means "No data"; clicking should clear any explicit assignment.
			MapState.AssignCountryToSet(countryId, null);
			return Task.CompletedTask;
		}

		// Toggle behavior: clicking an already-assigned country clears it.
		var current = MapState.GetAssignedSetId(countryId);
		if (current == _activeSetId)
		{
			MapState.AssignCountryToSet(countryId, null);
		}
		else
		{
			MapState.AssignCountryToSet(countryId, _activeSetId);
		}

		return Task.CompletedTask;
	}

	private void ImportYaml()
	{
		_yamlError = "";
		_yamlWarnings = new List<string>();
		_yamlImported = false;

		try
		{
			var result = _yamlImporter.Parse(_yamlText);
			MapState.ReplaceAll(result.Sets, result.CountryAssignments);

			if (!string.IsNullOrWhiteSpace(result.MapName))
			{
				_mapName = result.MapName.Trim();
			}

			_activeSetId = null;
			_yamlWarnings = result.Warnings.ToList();
			_yamlImported = true;
		}
		catch (Exception ex)
		{
			_yamlError = ex.Message;
		}
	}

	private async Task ExportYaml()
	{
		_yamlError = "";
		_yamlWarnings = new List<string>();
		_yamlImported = false;

		try
		{
			var yaml = BuildYamlExport();
			var timestamp = DateTimeOffset.Now.ToString("yyyy-MM-dd_HHmmss");
			var baseName = string.IsNullOrWhiteSpace(_mapName) ? "World Map" : _mapName.Trim();
			var fileName = $"{ToSafeFileName(baseName)}_{timestamp}.yaml";
			await Js.InvokeVoidAsync("appInterop.downloadTextFile", fileName, "text/yaml;charset=utf-8", yaml);
		}
		catch (Exception ex)
		{
			_yamlError = ex.Message;
		}
	}

	private string BuildYamlExport()
	{
		var mapName = string.IsNullOrWhiteSpace(_mapName) ? "World Map" : _mapName.Trim();

		// Export sets and their explicit assignments. The default "No data" group is implicit
		// and is not exported.
		var sets = MapState.GetSets().Where(s => s.Id != MapState.DefaultSetId).ToList();
		var assignments = MapState.GetCountryAssignments();

		var bySet = assignments
			.Where(kvp => kvp.Value != MapState.DefaultSetId)
			.GroupBy(kvp => kvp.Value, kvp => kvp.Key.ToUpperInvariant())
			.ToDictionary(g => g.Key, g => g.OrderBy(x => x, StringComparer.Ordinal).ToList());

		static string YamlEscape(string value)
		{
			if (value is null)
			{
				return "\"\"";
			}

			var v = value.Replace("\\", "\\\\").Replace("\"", "\\\"");
			return $"\"{v}\"";
		}

		var sb = new System.Text.StringBuilder();
		sb.AppendLine($"mapName: {YamlEscape(mapName)}");
		sb.AppendLine("sets:");
		foreach (var set in sets)
		{
			sb.AppendLine($"  - name: {YamlEscape(set.Name)}");
			sb.AppendLine($"    color: {YamlEscape(set.ColorHex)}");

			if (bySet.TryGetValue(set.Id, out var countries) && countries.Count > 0)
			{
				sb.AppendLine("    countries:");
				foreach (var c in countries)
				{
					sb.AppendLine($"      - {c}");
				}
			}
		}

		return sb.ToString();
	}

	private static string ToSafeFileName(string name)
	{
		if (string.IsNullOrWhiteSpace(name))
		{
			return "map";
		}

		var cleaned = name.Trim();
		foreach (var ch in System.IO.Path.GetInvalidFileNameChars())
		{
			cleaned = cleaned.Replace(ch, '-');
		}

		// Avoid trailing dots/spaces (Windows-friendly).
		cleaned = cleaned.Trim().TrimEnd('.');
		return string.IsNullOrWhiteSpace(cleaned) ? "map" : cleaned;
	}

	private void ClearYaml()
	{
		_yamlText = "";
		_yamlError = "";
		_yamlWarnings.Clear();
		_yamlImported = false;
	}

	private void ToggleYamlImport()
	{
		_yamlImportExpanded = !_yamlImportExpanded;
	}

	public void Dispose()
	{
		MapState.StateChanged -= OnStateChanged;
	}
}
